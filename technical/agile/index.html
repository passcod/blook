<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AGILE - Félix Saparelli</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Félix Saparelli</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/passcod/blook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-cost-effective-agile"><a class="header" href="#a-cost-effective-agile">A cost-effective AGILE</a></h1>
<blockquote>
<p>August 2022 <strong>Work in progress</strong></p>
</blockquote>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Earlier this year <a href="https://twitter.com/passcod/status/1548245821426401282">I got interested</a> in <a href="https://news.stanford.edu/2022/06/27/new-optical-device-help-solar-arrays-focus-light-even-clouds/">a Stanford article</a> and <a href="https://www.nature.com/articles/s41378-018-0015-4">a Nature paper</a> that used a device
called an AGILE (Axially Graded Index LEns) to enhance solar panels. An AGILE is a complex bit of
glass-like plastic that resembles an upside-down truncated cone or pyramid.</p>
<p>I’ll quickly summarise the papers:</p>
<p>The principle is pretty simple: the pyramid is made of a series of horizontal layers with increasing
refractive indices going deeper (towards the narrow end), and the sloped sides are coated with a
reflective material. Any light that enters the wide top of the device is curved towards the bottom
by the successive layers, and reflecting against the sides only increases the effect due to the
angle. In the end, all light that enters the top of the AGILE at any angle will exit at the bottom.</p>
<p>Due to the angle, the top surface is larger than the bottom, which means that light is effectively
concentrated. At a wild guess, if the top surface is four times the bottom, then the light will be
four time concentrated on average.</p>
<p>The AGILE also concentrates input light that arrives at any angle and curves it such that it
exits the lens at angles that are bound by the angles of the device.</p>
<p>These properties make AGILEs an attractive solution for increasing the cost-effectiveness of solar
panels: not only can the active surface (the part actually covered in photovoltaics) be reduced
compared to the solar panel’s total surface, but the panel can operate at much wider input angles,
which is a well-known issue with solar installations, and it does so with a static and completely
passive device that doesn’t require much overhead in terms of space.</p>
<h2 id="building-one"><a class="header" href="#building-one">Building one</a></h2>
<p><a href="https://snfexfab.stanford.edu/sites/g/files/sbiybj8726/f/sections/diplayfiles/ee412_finalreport-gradedindex.pdf">This paper</a> describes how to build an AGILE:</p>
<ol>
<li>Obtain a set of optical (i.e. extremely clear) resins that can be cured with UV and have a range
of refractive indices (RI) when cured. Remember this bit.</li>
<li>Build a mould: a 3D printer does the trick here, plus some post-processing (sanding) to smooth
the sides. The researchers seem to have directly built the negative, but it might be easier for
repeatability and ease of demoulding to print the positive and make a silicon mould.</li>
<li>Pour a layer of the highest RI resin.</li>
<li>Cure it with a UV lamp.</li>
<li>Repeat 3–4 with decreasing RI resins.</li>
<li>Demould the pyramid, finish the edges.</li>
<li>Coat the angled sides with a reflective layer. It might be sufficient to spray paint a high
concentration mixture of silver pigment powder and acrylic base, or a deposition process could be
used with silver nitrate.</li>
</ol>
<p>So, that’s pretty simple, and it sounds doable in DIY, right?</p>
<p>Step one, obtain a set of optical resins, like, uhhh, <a href="https://www.norlandproducts.com/adhchart.html">these ones</a>. Wait, what’s the price
of those? Uhhh $230 USD per pound, so about $500 USD per kilogram. And you’d need at least five, so
for a kg of each that will come to a shiny $2500 USD just to get started. I can’t imagine we’d need
<em>less</em> than about a kilo total per panel, given some maths that I’ll leave to reader discretion, so
at a glance we’re looking at a cool $500 USD per ~standard two square metre solar panel. Plus the
cost of the photovoltaics and frame and so on, but that’s decently cheap, on the range of $100 USD.</p>
<p>So we’re looking at a device that <em>at least quintuples</em> the cost of a solar panel, just to get some
better utilisation in the mornings and evenings. Not very cost effective, <em>and</em> prohibitive for DIY.</p>
<h2 id="alternative-materials"><a class="header" href="#alternative-materials">Alternative materials</a></h2>
<p>Can we find alternative materials that are much cheaper and would allow us to control their RI?
Well, solids are a no. Resins are it, and finding optical-grade resins with precise RIs… we’re
back at square one. Glasses are a no-go. Diamond and other lattices or crystals are also exorbitant.</p>
<p>What about liquids? No, hear me out.</p>
<p>Glycerol (also called glycerine) is “<a href="https://en.wikipedia.org/wiki/Glycerol">a colorless, odorless, viscous liquid that is sweet-tasting
and non-toxic</a>.” It’s also miscible in water. And it has a RI of 1.46. Water, by the
by, has a RI of 1.33.</p>
<p>Mixing glycerol and water at varying ratios <em>changes the RI of the mixture</em> in between these two
extremes. Further, adding a water-soluble compound, like sugar or salt, may <em>increase</em> the RI, for
some fine tuning.</p>
<p>So, if we can create water-glycerol compounds at precise ratios, we can possibly get a set of
colorless odorless non-toxic liquids that have a range of RI, from 1.33 to 1.46.</p>
<p>We can then layer these liquids, partitioned by much thinner pieces of a strong plastic, like
acrylic which has a higher RI at 1.50, but the thickness difference should make that negligible. The
bottom of this new AGILE can then be a thicker bit of acrylic, for the final step at 1.50.</p>
<p>What’s the cost of glycerol? <a href="https://www.purenature.co.nz/products/vegetable-glycerine-refined-palm-free?_pos=3&amp;_sid=dc0f74cf3&amp;_ss=r">Less than $10 USD per kg</a>. Acrylic sheeting is about $20
USD per square metre depending on thickness and retailer. Water will need to be pure or distilled,
and that costs about $0.50 USD per litre.</p>
<p>Pro: we’re looking at something about 40 times cheaper than with resins.</p>
<p>Con: it sounds absolutely bonkers.</p>
<h2 id="preliminaries"><a class="header" href="#preliminaries">Preliminaries</a></h2>
<p>We need to do a few things before we can actually get to the hands on bit:</p>
<h3 id="build-or-obtain-some-kind-of-rig-or-tool-to-measure-ri"><a class="header" href="#build-or-obtain-some-kind-of-rig-or-tool-to-measure-ri">Build or obtain some kind of rig or tool to measure RI</a></h3>
<p>I… thought this was going to be hard, but actually refractometres are very common! Turns out
they’re used a lot in a (somewhat dodgy-sounding tbh, how would you control for other effects by
contaminants?) practice to measure the amount of sugar in a solution, like fruit juices, or
conversely the amount of water in a sugary liquid, like honey. And apparently also for alcohol in
wines and beer. Again, I’m a bit concerned here, in many wines and some beers you’d have both
alcohol and sugar, surely that would be hard to distinguish? But whatever, I don’t know enough about
it.</p>
<p>For my uses, though: an analog refractometre is about $20, and a digital one around $150. Digital
ones are much more precise, but finding one that has both the required range <em>and</em> shows the RI
value instead of some derived specialised unit like Brix was quite tough! I bought both an analog
and a digital one; after this project I’m sure I can find other uses, and mum <em>does</em> keep bees, so.</p>
<h3 id="find-some-photovoltaic-cells-not-entire-panels-and-rig-at-least-one-to-measure-output-current"><a class="header" href="#find-some-photovoltaic-cells-not-entire-panels-and-rig-at-least-one-to-measure-output-current">Find some photovoltaic cells (not entire panels) and rig at least one to measure output current</a></h3>
<p>Finding them is easy: AliExpress has a selection, and I picked <a href="https://www.aliexpress.com/item/4000511987311.html">one</a>.</p>
<p>I picked them on a combination of price, stated power output, and shape. 52mm squares sounds pretty
good to me, it will let me work at the macro level. The research cited above worked at much smaller
sizes, with AGILEs on the order of 10mm wide or less. I was concerned about this because finding
cells that tiny is tougher, and the wiring will get annoying, but most importantly the experimental
setup seen in one of these papers looked to me like the agile didn’t cover the entire cell. That
felt like a waste of some of the cell, and could even affect measurements.</p>
<p>So anyway, I bought a stack of cells, and I’m awaiting them. I’ll be measuring output current with
my regular ampmeter.</p>
<h3 id="figure-out-what-the-optimal-size-of-the-device-and-the-number-ris-and-thicknesses-of-the-layers-is"><a class="header" href="#figure-out-what-the-optimal-size-of-the-device-and-the-number-ris-and-thicknesses-of-the-layers-is">Figure out what the optimal size of the device and the number, RIs, and thicknesses of the layers is</a></h3>
<p>This is probably the bit you’re here for. The rest of the article will be updated when I make
progress on the physical construction of the object.</p>
<p>I want not only to construct an AGILE, but I want to construct the <em>best</em> AGILE I can with my
constraints. To do that, I’m going to define a model for simulation, parametrise it, assign a score
to a parameter set, and then run an exhaustive search on the parameter space, to finally rank and
find the ideal AGILE I can make.</p>
<p>“Exhaustive? That’s gonna take forever!”</p>
<p>Well, I’ll use Rust for the actual compute, and I’m going to start by strictly defining the model to
both get an idea of the possibility space and to figure out how many calculations I’ll need to do,
as well as a simple estimate of how long it will take.</p>
<h4 id="the-model"><a class="header" href="#the-model">The model</a></h4>
<p>So, I’m going to take the AGILE object, and I’m going to cut a section down the middle:</p>
<p><img src="./scad-section-preview.png" alt="a 3D render of the pyramid with a sectioning plane down the middle" /></p>
<p>Which will look like this in 2D:</p>
<p><img src="./section-bare.png" alt="that section drawn on a grid, with points named A through D starting on the top left and going clockwise" /></p>
<p>On that top surface, in the diagram labelled A–B, I’m going to define a series of entry points at
regular intervals starting from one end (A) to the other (B). The distance from the last point to
the end will not always be an exact interval, of course. In the below diagram I’m showing points
every 10 units, but in the actual simulation I’m going to go with every 1mm for extra precision.</p>
<p><img src="./section-dotted.png" alt="the same diagram but with nineteen points E through M spread out on the top segment" /></p>
<p>From each of these points I’m going to define a set of angles of incidence. Again in the diagram I’m
showing only a few angles on a few points for clarity, but in the simulation I’ll go with integer
angles from 1° to 179° inclusive, except at the two extremes where it doesn’t make sense, and the
range will be bound a little tighter.</p>
<p><img src="./section-angles.png" alt="the same diagram but three points have many lines going at various angles from them and extending upwards" /></p>
<p>For each of these angles at each of these points, I’ll compute the path the ray of light takes
inside the lens, where it exits, and at what angle. Then, over the the entire set of rays of a
particular parametrised AGILE, I’ll calculate:</p>
<ul>
<li>the proportion of rays that exit at the bottom (higher is better)</li>
<li>the average exit angle for those that exit at the bottom (closer to vertical is better)</li>
<li>the length of the path the light takes inside the lens (lower is better)</li>
</ul>
<p>Combining these three measures, weighted in that order, will produce a single score for any given
parameter set. Getting that score will mean computing 178 (entry angles) × 105 (entry points) rays
given a fixed 104mm top width for the section, so at most 18690 rays per param set.</p>
<h4 id="model-parameters"><a class="header" href="#model-parameters">Model parameters</a></h4>
<p>So, the way the AGILE is going to be constructed, it’s going to be a laminate of thinner
<em>partitions</em>, made of acrylic, and thicker <em>layers</em>, which are filled with a liquid. The top and
bottom will be partitions, and there will be a partition in between each layer.</p>
<p><img src="./section-layered.png" alt="the diagram without the entry points and incidence lines but with the partitions and layers as described" /></p>
<p>The thickness of the partitions is the same for all, and for model simplicity I’ll say that the
thickness of the layers is also the same through the AGILE. If the model works out to be
sufficiently fast, these could be made to vary, to possibly get more options or better optimisation.</p>
<p>The RI of each layer will be a variable. For model simplicity I won’t constrain the layers to be in
increasing RI top to bottom; that’s likely what it will work out to anyway but maybe there will be
some surprising behaviour coming out of that.</p>
<p>The number of layers will also be a variable.</p>
<p>The width of the bottom is set to 52mm because that’s the size of the PV cell tiles I’ve bought. I’m
going to set that the top width be 104mm, exactly twice, for now. Making it a variable increases the
possibility space a lot; for now I’ll keep it fixed.</p>
<p>With all this, the height of the pyramid will be determined entirely by the variables above.</p>
<p>The variable set will be described like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ParamSet {
  /// RI of the layers
  ///
  /// This specifies both the _amount_ of layers (number of elements in
  /// the slice) and the _refractive index_ of each.
  layers_ri: &amp;[f64],

  /// Thickness of each layer in tenths of mm
  layers_thickness: u32,

  /// Thickness of each partition in tenths of mm
  partitions_thickness: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>On top of this, there will also be some bounds:</p>
<ul>
<li>The number of layers will be minimum 2, maximum 10. Two is the minimum useful, ten is arbitrary.</li>
<li>The thickness of partitions will be minimum 0.2mm, maximum 3mm, from the set <code>0.2mm</code>, <code>0.4mm</code>,
<code>0.6mm</code>, <code>0.8mm</code>, <code>1.0mm</code>, <code>1.2mm</code>, <code>1.5mm</code>, <code>2.0mm</code>, <code>3.0mm</code>. These are supply constraints, save
for the maximum which is arbitrary.</li>
<li>The thickness of layers will be minimum 3mm, maximum 28.6mm, in increments of 0.1mm. The bounds are
arbitrary on a general gut feel of what will be useful; the increment is the precision of a 3D
printer. The range is chosen so it fits in a <code>u8</code>.</li>
<li>The refractive indices will be minimum 1.33, maximum 1.50, in increments of 0.01. I don’t yet know
if it will be possible to measure or control RI to that precision, but it seems more likely than
0.001. The minimum is water (1.333), the maximum is acrylic (1.50): we could totally have a layer
that it entirely acrylic. RIs between 1.46 (pure glycerol) and 1.50 are yet unknown if they are
achievable (with additives?) but it would be easier to <em>exclude</em> results with these values rather
than not generate them in the first place and then find out we could have.</li>
</ul>
<p>So, to finish our estimate and get onto the modelling work:</p>
<ul>
<li>Number of layers: 8 possibilities</li>
<li>Thickness of layers: 256</li>
<li>Thickness of partitions: 9</li>
<li>Refractive indices: 17 increments per layer, so 17×10=170 worst case</li>
</ul>
<p>Possibility space is thus at most 8×256×9×170 = <strong>3 133 440</strong>.</p>
<p>Multiplied by the amount of rays to compute for each param set, we need to perform about 60 billion
ray computes, or about 2 trillion individual refraction and reflection calculations.</p>
<p>Welp, that’s a lot. Gotta go fast!</p>
<blockquote>
<p>Hold on.</p>
</blockquote>
<p>What?</p>
<blockquote>
<p>It’s not 17 <em>times</em> 10.</p>
</blockquote>
<p>Huh? Oh. Oh no.</p>
<p>It’s 17 possibilities, in 10 boxes. Oh no. It’s 17 <strong>to the power of 10</strong>.</p>
<p>(Actually, it’s 17¹+17²+17³+… 17¹⁰ but that’s only marginally larger than 17¹⁰.)</p>
<p>That makes the possibility space about, uhhh, <strong>39 481 224 546 373 632</strong>? 39 quadrillions?
I’m not super loving it.</p>
<h4 id="evolving-past-this"><a class="header" href="#evolving-past-this">Evolving past this</a></h4>
<p>Alright, so, an exhaustive search is firmly out. What else is out there?</p>
<p>Well, this entire project is for fun, and I’ve always wanted to play around
with genetic algorithms. They just sound so neat! This seems like the perfect
pretext.</p>
<p>The first interesting crate I find is <a href="https://lib.rs/crates/genevo">genevo</a>. It looks complete and flexible.
Let’s try it out.</p>
<p><img src="./one-eternity-later.jpg" alt="“one eternity later” (the spongebob meme)" /></p>
<p>Implementing the genetic algorithm machinery with genevo was very soothing, really. Just keep
plugging at it until the thing compiles. A very Rusty afternoon.</p>
<p>However, I come to running it and I find that at the start of the process, I defined my fitness
function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fitness_of(&amp;self, params: &amp;ParamSet) -&gt; u64 {
  raytrace(*params).summarise()
}
<span class="boring">}</span></code></pre></pre>
<p>What does that summarise function do? Well, it just summarises Performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug)]
pub struct Performance {
	/// Proportion of rays that exit at the bottom.
	///
	/// Calculated as {bottom exit rays} * u32::MAX / {total rays}.
	///
	/// Higher is better.
	pub exit_ratio: u32,

	/// Average of exit angles (to the normal) for rays that exit at the bottom.
	///
	/// In 10000th Angle.
	///
	/// Lower is better.
	pub exit_angle: u32,

	/// Total distance light travels inside the lens.
	///
	/// In micrometres.
	///
	/// Lower is better.
	pub light_travel: u32,
}

impl Performance {
	pub fn summarise(self) -&gt; u64 {
		let one = self.exit_ratio as u64;
		let two = u32::MAX.saturating_sub(self.exit_angle) as u64;
		let three = u32::MAX.saturating_sub(self.light_travel) as u64;

		one * 10 + two * 5 + three
	}
}
<span class="boring">}</span></code></pre></pre>
<p>And how do I <em>get</em> a Performance? Ah:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn raytrace(params: ParamSet) -&gt; Performance {
  todo!()
}
<span class="boring">}</span></code></pre></pre>
<h4 id="raytracing-but-like-the-hard-way"><a class="header" href="#raytracing-but-like-the-hard-way">Raytracing. But like, the hard way.</a></h4>
<p>I barely know enough about it to know that the activity is called raytracing, and that it’s <a href="https://en.wikipedia.org/wiki/Ray_tracing_(physics)">not the
3D graphics kind of raytracing</a>. Something that’s mentioned pretty early on is
<a href="https://en.wikipedia.org/wiki/Maxwell&#x27;s_equations">Maxwell’s equations</a>, which is an intolerable amount of maths, fuck that.</p>
<p>No, failing to find any physics raytracing crates, I’m going to use good old <a href="https://en.wikipedia.org/wiki/Snell&#x27;s_law">the laws of
refraction</a> and the law of reflection. Very simply:</p>
<ul>
<li>Refraction: <code>sin(input) / sin(output) == ri(output) / ri(input)</code></li>
<li>Critical input angle: <code>arcsin(ri(output)/ri(input))</code>, where the output is always 90°</li>
<li>Total internal reflection: when the input angle is higher than the critical angle</li>
<li>Reflection: output angle == input angle, but staying on the same side</li>
</ul>
<p>All angles are to the <em>normal</em>, that is the perpendicular to the plane upon which the ray is
reflecting or through which it is refracting. (If it’s not a plane it’s perpendicular to the tangent
at that point, but in my model everything is planes, so idgaf.)</p>
<p>If you’ve done high school physics, you probably remember this.</p>
<p>Coding up these things is pretty easy. The hard bit is figuring out where a ray <em>is</em> in the model,
what boundary it will be intersecting with <em>next</em>, at what angle, and at what position.</p>
<p>At first I thought, you know what, I’ll do it with a turtle. I’ll advance my ray a bit, I’ll take
note of what I passed through, and</p>
<p>wait, how will I know I’ve passed something <em>through</em>?</p>
<p>and I basically got stuck there.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../updates/projects/accord.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../updates/projects/armstrong.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../updates/projects/accord.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../updates/projects/armstrong.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
