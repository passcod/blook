<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2025 | AI Log - Félix Saparelli</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Félix Saparelli</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/passcod/blook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ai-log"><a class="header" href="#ai-log">AI Log</a></h1>
<p>This is a diary where I record every single interaction I knowingly have with
an genAI system, over a one-month period from 2025-06-21 to 2025-07-20.</p>
<p>Records are made first briefly by pasting text or code, and then revised with
more detail later. This may give the impression that I constantly interrupted
myself recording the interaction, but in fact most of the explanations
describing the sequences of actions are reconstructed, then when appropriate or
relevant an analysis is added on top. While I’ve recorded almost every
interaction, and tried to preserve notes as best I could, the final version
you’re reading has had several edit passes for clarity as well as redaction
when appropriate (every single interaction means not only for personal use, but
also for work — in fact most of the events are for work, as I simply don’t use
AI a lot outside of that for various reasons).</p>
<p>Most of this will be in code editors. I indicate the model when known. I have
free access to Github Copilot Pro via opensource contributions (or something,
idk what the criteria is exactly), I also use the free default tier of Zed’s AI
models, and occasionally I might use local models run on GPU via Ollama or LM
Studio. When not in code editors, I may use Gemini as part of my workplace’s
Google subscription, and other genAIs embedded in various products.</p>
<p>Google Translate and transcription services are not considered genAI by this
research. Summaries on top of transcriptions are.</p>
<p>Times are approximate and largely reconstructed.</p>
<p>Cursor position when relevant is indicated with ‡.</p>
<p>This is a tremendously long document; if you’re looking for overall analysis
and retrospective, that will come in a later post: there is no point scrolling
to the end if you’re not interested in the minutiae of the data.</p>
<h2 id="2025-06-20"><a class="header" href="#2025-06-20">2025-06-20</a></h2>
<h3 id="2330--zed--claude-sonnet-37"><a class="header" href="#2330--zed--claude-sonnet-37">23:30 | Zed | Claude Sonnet 3.7</a></h3>
<p>I was writing a parser for the Mercurial ignore format. I typed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn line&lt;'src&gt;() -&gt; impl Parser&lt;'src, &amp;'src str, Line, ParserErr&lt;'src&gt;&gt; {
    let ‡
}
<span class="boring">}</span></code></pre></pre>
<p>and hit Tab reflexively. By all expectations, I shouldn’t have gotten anything.
Instead, Zed autocompleted the entire function body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn line&lt;'src&gt;() -&gt; impl Parser&lt;'src, &amp;'src str, Line, ParserErr&lt;'src&gt;&gt; {
	let prefix = choice((
		"re:".to_string().padded().map(|_| Prefix::Re),
		"path:".to_string().padded().map(|_| Prefix::Path),
		"file:".to_string().padded().map(|_| Prefix::FilePath),
		"relpath:".to_string().padded().map(|_| Prefix::RelPath),
		"rootfilesin:".to_string().padded().map(|_| Prefix::RootFilesIn),
		"relglob:".to_string().padded().map(|_| Prefix::RelGlob),
		"relre:".to_string().padded().map(|_| Prefix::RelRe),
		"glob:".to_string().padded().map(|_| Prefix::Glob),
		"rootglob:".to_string().padded().map(|_| Prefix::RootGlob),
		"include:".to_string().padded().map(|_| Prefix::Include),
		"subinclude:".to_string().padded().map(|_| Prefix::SubInclude),
		"syntax:".to_string().padded().map(|_| Prefix::Syntax),
	));

	let pattern = text::ident().map(|s| s.to_string());

	let comment = text::until(newline()).map(|s| s.to_string());

	let line = prefix
		.or_not()
		.then(pattern.or_not())
		.then(comment.or_not())
		.map(|(prefix, pattern, comment)| Line {
			prefix,
			pattern,
			comment,
		});

	line
}
<span class="boring">}</span></code></pre></pre>
<p>I was trying to deliberately think through parser approach and design, so it
was kinda unwanted.</p>
<p>For this experiment’s sake, though, I decided to keep it initially and review
instead of immediately hitting Undo:</p>
<ul>
<li><code>"string".to_string().padded().map(...)</code> is nonsense. this isn’t how the
chumsky API works at all. Instead, I’d write something like
<code>just("string").padded().to(...)</code>.</li>
<li>even then, adding the padding to every call is silly, and also wrong, as
whitespace is significant in this context.</li>
<li>the pattern part can be considerably more things than would be matched by
<code>text::ident</code>.</li>
<li>the comment part needs to come after a <code>#</code>, which is completely absent from
this approach</li>
<li>the comment part also assumes that there will be a newline in the input,
which is nonsense, especially in chumsky’s approach that parsers are complete
by default.</li>
</ul>
<p>All in all, this was an unwanted interaction that had the right general
structure but was utterly wrong on most details. I scrapped it and continued by
hand, as I’d initially intended.</p>
<h3 id="2332--zed--claude-sonnet-4"><a class="header" href="#2332--zed--claude-sonnet-4">23:32 | Zed | Claude Sonnet 4</a></h3>
<p>I typed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn line&lt;'src&gt;() -&gt; impl Parser&lt;'src, &amp;'src str, Line, ParserErr&lt;'src&gt;&gt; {
	let prefix = choice((
		just("re").to(Prefix::Re),
    ‡
  ));

  todo()
}
<span class="boring">}</span></code></pre></pre>
<p>and then let autocomplete suggest the following lines, reviewed the preview, and accepted:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn line&lt;'src&gt;() -&gt; impl Parser&lt;'src, &amp;'src str, Line, ParserErr&lt;'src&gt;&gt; {
	let prefix = choice((
		just("re").to(Prefix::Re),
		just("path").to(Prefix::Path),
		just("file").to(Prefix::FilePath),
		just("relpath").to(Prefix::RelPath),
		just("rootfilesin").to(Prefix::RootFilesIn),
		just("relglob").to(Prefix::RelGlob),
		just("relre").to(Prefix::RelRe),
		just("glob").to(Prefix::Glob),
		just("rootglob").to(Prefix::RootGlob),
		just("include").to(Prefix::Include),
		just("subinclude").to(Prefix::SubInclude),
		just("syntax").to(Prefix::Syntax),
	));

  todo()
}
<span class="boring">}</span></code></pre></pre>
<p>I then went to review the literals for the prefixes from the source material.</p>
<ul>
<li><code>file</code> was wrong; it should have been <code>filepath</code>. Kinda baffling that it got that wrong given it correctly replicated the variant name.</li>
</ul>
<h2 id="2025-06-21"><a class="header" href="#2025-06-21">2025-06-21</a></h2>
<h3 id="0122--zed--claude-sonnet-4"><a class="header" href="#0122--zed--claude-sonnet-4">01:22 | Zed | Claude Sonnet 4</a></h3>
<p>I added the <code>, pattern</code> part below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|(prefix, pattern‡)| Line {
			prefix,
			pattern: None,
			comment: None,
		})
<span class="boring">}</span></code></pre></pre>
<p>And accepted an edit suggestion for the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|(prefix, pattern)| Line {
			prefix,
			pattern,
			comment: None,
		})
<span class="boring">}</span></code></pre></pre>
<h3 id="0125--zed--claude-sonnet-4"><a class="header" href="#0125--zed--claude-sonnet-4">01:25 | Zed | Claude Sonnet 4</a></h3>
<p>I started with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|(prefix, pattern)| Line {
			prefix,
			pattern,
			comment: None,
		})
<span class="boring">}</span></code></pre></pre>
<p>Then I edited it like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|((prefix, pattern)‡)| Line {
			prefix,
			pattern,
			comment: None,
		})
<span class="boring">}</span></code></pre></pre>
<p>Edit prediction proposed this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|((prefix, pattern, comment))| Line {
			prefix,
			pattern,
			comment: None,
		})
<span class="boring">}</span></code></pre></pre>
<p>I accepted, and in part because of type inlays I didn’t immediately realise that this was not what I wanted.</p>
<p>I then accepted the next edit suggestion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|((prefix, pattern, comment))| Line {
			prefix,
			pattern,
			comment,
		})
<span class="boring">}</span></code></pre></pre>
<p>And then figured it out, hit Undo twice, and wrote the correct change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    .map(|((prefix, pattern), comment)| Line {
			prefix,
			pattern,
			comment,
		})
<span class="boring">}</span></code></pre></pre>
<h3 id="0315--zed--claude-sonnet-4"><a class="header" href="#0315--zed--claude-sonnet-4">03:15 | Zed | Claude Sonnet 4</a></h3>
<p>I started writing</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pattern‡
<span class="boring">}</span></code></pre></pre>
<p>and the autocomplete started suggesting something like</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pattern_syntax&lt;'src&gt;() -&gt; impl Parser&lt;'src...
<span class="boring">}</span></code></pre></pre>
<p>including an entire body. This was not what I wanted at all, so I had to kill
the suggestion and continue by hand.</p>
<h3 id="0350--zed--claude-sonnet-4"><a class="header" href="#0350--zed--claude-sonnet-4">03:50 | Zed | Claude Sonnet 4</a></h3>
<p>I started writing an if-else expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.map(|opt| opt.and_then(|pat| if pat.is_empty()‡ )),
<span class="boring">}</span></code></pre></pre>
<p>and it autocompleted correctly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.map(|opt| opt.and_then(|pat| if pat.is_empty() { None } else { Some(pat) })),
<span class="boring">}</span></code></pre></pre>
<h2 id="2025-06-22"><a class="header" href="#2025-06-22">2025-06-22</a></h2>
<h3 id="0330-to-0430--zed--claude-sonnet-4"><a class="header" href="#0330-to-0430--zed--claude-sonnet-4">03:30 to 04:30 | Zed | Claude Sonnet 4</a></h3>
<p>A series of about 20 interactions where my code editor would keep suggesting
stupid shit and I had to keep telling it to fuck off.</p>
<h3 id="2045--zed--claude-sonnet-4"><a class="header" href="#2045--zed--claude-sonnet-4">20:45 | Zed | Claude Sonnet 4</a></h3>
<p>While mass-rewriting tests using multiple selections, two weren’t in the same
layout as the others and got messed up. I fixed the first by hand, then Zed
proposed an autocorrection for the second.</p>
<p>From:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Glob((
  Some(vec![Class(Klass {
    negated: false,
    classes: vec![Single(']'), Single('-'),],
  })]),
  Vec::new()
)),
<span class="boring">}</span></code></pre></pre>
<p>To:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
  Some(Glob(vec![Class(Klass {
    negated: false,
    classes: vec![Single(']'), Single('-'),],
  })])),
  Vec::new()
),
<span class="boring">}</span></code></pre></pre>
<h3 id="2120--zed--claude-sonnet-4"><a class="header" href="#2120--zed--claude-sonnet-4">21:20 | Zed | Claude Sonnet 4</a></h3>
<p>Writing a test, I started writing the expected value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn segmented() {
	use Token::*;
	assert_eq!(
		glob().parse(r"a/b/c").into_result(),
		Ok(Glob(vec![‡]))
	);
}
<span class="boring">}</span></code></pre></pre>
<p>Zed offered a completion, which was correct so I accepted:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn segmented() {
	use Token::*;
	assert_eq!(
		glob().parse(r"a/b/c").into_result(),
		Ok(Glob(vec![Literal("a".into()), Separator, Literal("b".into()), Separator, Literal("c".into())]))
	);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2025-06-23"><a class="header" href="#2025-06-23">2025-06-23</a></h2>
<h3 id="0330--duckduckgo"><a class="header" href="#0330--duckduckgo">03:30 | DuckDuckGo</a></h3>
<p>Searched for <code>stray digicode safe</code>. The “AI assist” feature returned two codes,
one of which I already had. The second worked in game, so I didn’t look further.</p>
<h3 id="1305--zed--claude-sonnet-4-thinking"><a class="header" href="#1305--zed--claude-sonnet-4-thinking">13:05 | Zed | Claude Sonnet 4 Thinking</a></h3>
<p>I couldn’t recall the named captures regex syntax so I wrote:</p>
<pre><code class="language-js">if (!/\/(?&lt;&gt;:‡\d+)$/.test(step)) {
</code></pre>
<p>and paused to let Zed complete:</p>
<pre><code class="language-js">if (/\/(?&lt;step&gt;[^/]+)\/(?&lt;version&gt;\d+)$/.test(step)) {
</code></pre>
<p>On one hand, that does show me the right syntax, but on the other, it
hallucinated a whole additional capture and an input syntax that was not what I
was looking for, and also discarded the NOT operator.</p>
<h3 id="1306--zed--claude-sonnet-4-thinking"><a class="header" href="#1306--zed--claude-sonnet-4-thinking">13:06 | Zed | Claude Sonnet 4 Thinking</a></h3>
<p>Having rewritten the regex to match what I wanted, I applied it to my input:</p>
<pre><code class="language-js">const re = /^(?&lt;file&gt;.+?)(\/(?&lt;version&gt;\d+))?$/;
const { file, ‡ }
</code></pre>
<p>Autocompleted:</p>
<pre><code class="language-js">const re = /^(?&lt;file&gt;.+?)(\/(?&lt;version&gt;\d+))?$/;
const { file, version } = re.exec(step)?.groups || {};
</code></pre>
<h3 id="1335--zed--claude-sonnet-4-thinking"><a class="header" href="#1335--zed--claude-sonnet-4-thinking">13:35 | Zed | Claude Sonnet 4 Thinking</a></h3>
<p>I copied a test case block to modify it into a new one, rewrote the <code>it</code>
description…</p>
<pre><code class="language-ts">it('needsStep throws when index is missing‡', async () =&gt; {
  expect(needsStep('steps/1749079898013-initDeviceKey/0')).toBe(
    `${STEP_PREFIX}1749079898013-initDeviceKey/0`,
  );
});
</code></pre>
<p>and Zed autocompleted the modification to make the test go:</p>
<pre><code class="language-ts">it('needsStep throws when index is missing', async () =&gt; {
  expect(() =&gt; needsStep('steps/1749079898013-initDeviceKey')).toThrow(
    'You must provide an index when depending on upgrade steps',
  );
});
</code></pre>
<p>This does what I want and the test passes.</p>
<h3 id="1400--zed--claude-sonnet-4-thinking"><a class="header" href="#1400--zed--claude-sonnet-4-thinking">14:00 | Zed | Claude Sonnet 4 Thinking</a></h3>
<p>I added an alias in one file:</p>
<pre><code class="language-js">export const upgradeCommand = new Command('upgrade')
  .alias('migrate')
  .description('Upgrade Tamanu installation')
</code></pre>
<p>Then opened another very similar file and it suggested adding the same alias:</p>
<pre><code class="language-js">export const upgradeCommand = new Command('upgrade')‡
  .description('Upgrade Tamanu installation')
</code></pre>
<h3 id="1505--coderabbit"><a class="header" href="#1505--coderabbit">15:05 | CodeRabbit</a></h3>
<p>I accepted <a href="https://github.com/beyondessential/tamanu/pull/7867#discussion_r2160628686">a commitable suggestion from a review
comment</a>.
The diff it was showing was unnecessarily long for the one-line change it
proposed, but I figured it was just a generation error.</p>
<p>However, after apply I went to check its work and found out that it had indeed
completely fucked up, duplicating lines and breaking the build:</p>
<pre><code class="language-ts">export async function up(query: QueryInterface): Promise&lt;void&gt; {
export async function up(query: QueryInterface): Promise&lt;void&gt; {
  await query.sequelize.query(`
    CREATE OR REPLACE FUNCTION public.set_updated_at()
     RETURNS trigger
     LANGUAGE plpgsql
    AS $function$
    BEGIN
        IF (
            NEW IS DISTINCT FROM OLD AND
            NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at
        ) THEN
            NEW.updated_at := current_timestamp;
        END IF;
        RETURN NEW;
    END;
    $function$
  `);
}
}
</code></pre>
<h2 id="2025-06-24"><a class="header" href="#2025-06-24">2025-06-24</a></h2>
<h3 id="1600--zed--claude-sonnet-4-thinking"><a class="header" href="#1600--zed--claude-sonnet-4-thinking">16:00 | Zed | Claude Sonnet 4 Thinking</a></h3>
<p>I was looking for the correct journalctl incantation to get just the messages,
not the timestamps. I initially made a couple of regular DDG searches, but
wasn’t getting good results:</p>
<ul>
<li>journalctl without timestamps</li>
<li>journalctl just the message</li>
</ul>
<p>So I asked the chat-UI panel in my editor with the following prompt:</p>
<blockquote>
<p>give me the journalctl command to print logs with just the message content,
not other information like timestamp and unit</p>
</blockquote>
<p>Which returned the right answer (<code>-o cat</code>).</p>
<p>Granted, trying this exact phrase in DDG returns the same answer (via a SU question).</p>
<h2 id="2025-06-25"><a class="header" href="#2025-06-25">2025-06-25</a></h2>
<p>Nothing today as I worked support rather than dev.</p>
<h2 id="2025-06-26"><a class="header" href="#2025-06-26">2025-06-26</a></h2>
<h3 id="1540--coderabbit"><a class="header" href="#1540--coderabbit">15:40 | CodeRabbit</a></h3>
<pre><code class="language-ts">const encounterFacility = (
  await this.sequelize.query(
    `
      SELECT f.* FROM facilities f
      JOIN encounters e ON f.id = e.facilityId
      WHERE e.id = $encounterId
    `,
    {
      type: QueryTypes.SELECT,
      model: Facility,
      mapToModel: true,
      bind: {
        encounterId: this.encounterId,
      },
    },
  )
)?.[0];
</code></pre>
<p>Coderabbit suggested that I add error handling to this. Good call: I really miss
working with Rust in those instances, where it would just not have allowed me to
ignore the database error possibility.</p>
<p>However, Coderabbit suggested I wrap the entire thing in a try-catch, which
duplicated some downstream logic. Instead, I used the less-well-known but more
expressive 2-ary <code>.then()</code>:</p>
<pre><code class="language-ts">.then(
  (res: Facility[]) =&gt; res?.[0],
  (_err: Error) =&gt; null,
);
</code></pre>
<p>Which is really the spiritual equivalent of the Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query().and_then(|f| f.get(0)).unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<h3 id="1550--zed--claude-sonnet-4"><a class="header" href="#1550--zed--claude-sonnet-4">15:50 | Zed | Claude Sonnet 4</a></h3>
<p>Was typing this and wanted to tab-complete it:</p>
<pre><code class="language-ts">import { log } from '@tamanu/shared/services/‡';
</code></pre>
<p>What I was expecting:</p>
<pre><code class="language-ts">import { log } from '@tamanu/shared/services/logging';
</code></pre>
<p>What I got instead:</p>
<pre><code class="language-ts">import { log } from 'services/logging';
</code></pre>
<p>Mate how the fuck did you think deleting the package was a good idea???</p>
<h3 id="1700--github-copilot-chat--claude-sonnet-4"><a class="header" href="#1700--github-copilot-chat--claude-sonnet-4">17:00 | Github Copilot Chat | Claude Sonnet 4</a></h3>
<p>I was looking for what percentile I’m in, salary-wise, in New Zealand.</p>
<p>I downloaded a CSV from figure.nz but it wasn’t in the format I wanted, so I
got lazy and thought, okay, I’m gonna ask an AI to tell me how:</p>
<blockquote>
<p>given this CSV, write a Linux command line to extract only the rows of
“Number of people earning a wage/salary” for 2024</p>
</blockquote>
<p>As I finished typing, I realised this was actually pretty easy, so I went to do
this:</p>
<pre><code class="language-console">rg 2024.+earning file.csv &gt; output.csv
</code></pre>
<p>However, I checked back and the AI had done basically the same thing, but also
given me an extra option:</p>
<blockquote>
<p>If you want to include the header row as well, you can use:</p>
<pre><code class="language-console">awk -F',' 'NR==1 || ($1 == "2024" &amp;&amp; $3 == "Number of people earning a wage/salary")' file.csv
</code></pre>
</blockquote>
<p>That seemed even better, so I used it instead.</p>
<h2 id="2025-07-01"><a class="header" href="#2025-07-01">2025-07-01</a></h2>
<h3 id="2000--zed--claude-sonnet-4"><a class="header" href="#2000--zed--claude-sonnet-4">20:00 | Zed | Claude Sonnet 4</a></h3>
<p>Decided I should try to be make this a little more interesting and do agentic AI stuff.</p>
<p>Wrote a prompt, giving it the context of work’s repo LLM rules, and then instructing it:</p>
<blockquote>
<p>Write a plan into llm/plans/ for this: introduce a way for users to change
their own passwords. There must be a user profile in the frontend, which is
accessible from both facility and central server. That profile must have a
change password button and associated modal, which lets the user enter a new
password and a confirmation. The user model must be changed to allow
bidirectional syncing.</p>
</blockquote>
<p>It wrote a plan, which I reviewed. It had forgotten a bit, so I reprompted:</p>
<blockquote>
<p>You need to add the backend routes to both central server and facility server.</p>
</blockquote>
<p>I then reviewed the plan and was satisfied that it at least covered a good first try.</p>
<p><strong>This phase took 10 minutes.</strong></p>
<p>I then instructed to:</p>
<blockquote>
<p>Okay, start implementing the plan</p>
</blockquote>
<p>and started watching a youtube video.</p>
<p><strong>30 minutes later</strong>, it said it had finished phases 1-3, and if I wanted to
continue. I asked it to first commit the work, then continue. It issued the
following commands, with Zed prompting me every time:</p>
<pre><code class="language-bash">git add .
git status --porcelain
git commit -m "..." # with a commit message in convcommit format
</code></pre>
<p>Then continued with the implementation.</p>
<p>That took <strong>a further 6 minutes</strong>. Without prompting, it went to commit the
work using the same commands (and Zed prompted me to confirm).</p>
<p>During this second phase, it also edited the plan to mark things as complete,
and I was very happy to have committed the plan earlier, because it <em>completely
fucked it,</em> erased wide swathe of the plan, created duplicate headers, and put
things that were originally part of the plan (testing, documentation, gating
behind feature flag) in a neat little “next steps” section (and completely
forgot about the feature flag thing).</p>
<p>Then I pushed and created a draft PR. CodeRabbit then started doing a review
and summarisation, which took it 6 minutes. It picked up on many “obvious”
mistakes the coding agent made: bad imports, logic with security holes,
inconsistent errors, name conflicts in imports.</p>
<p>I then started manual review, and found:</p>
<ul>
<li>unwanted “features”, like having to enter your current password when changing
it, which was not in the plan nor prompt</li>
<li>slightly inconsistent password strength validation implemented in no less
than five different places</li>
<li>weird-ass formatting issues like multiple blank newlines and missing final
newline on some files</li>
<li>hardcoding colours and not using theme constants</li>
<li>using h6 headers for error text content instead of bold styling</li>
<li>inconsistent casing (kebab case vs camel case)</li>
</ul>
<p>Separately, Code Rabbit had a false positive where it claimed that something
was not done when it in fact was.</p>
<p>Another note is that humans would have committed <em>wayyyy</em> more often.</p>
<p>None of the two agents ever raised the truly interesting/challenging aspect of
this feature, which is how password updating should work securely in a
distributed-offline system with multiple authoritative servers that often
operate in “split brain” configurations. That’s genuinely hard and I don’t
really have a good idea right now about it.</p>
<p>This review took me 15 minutes.</p>
<p>Having done this, and convinced there’s no risk to deploy this to isolated test
infrastructure, I did so, to see if it actually worked. It did not.</p>
<h2 id="about-a-week-of-no-ai"><a class="header" href="#about-a-week-of-no-ai">about a week of no AI</a></h2>
<p>Kinda ruins the experiment but I was very tired of this shit. It’s extra
annoying to decide to not use AI for a bit because there’s no global “no AI”
toggle in Zed (or VSCode). So how this really manifested is that the
autocomplete would keep suggesting stuff and I would hit escape to quiet it,
repeatedly. Unfortunately there’s no actual intelligence I can talk to and say
“just shut up for now” — a complaint I have with a lot of other computers, from
Maps navigation while driving (I know the road and just want to listen to the
fucking podcast, shut up until we get to the bloody Auckland nightmare
exchanger) to ads (nuff said) to shops sending me fifty emails for a single
delivery (all I need is the tracking number and if there’s any delays in
sending it, not a by-the-minute report of how you’ve packed the order and then
a subpar proxying of the messages you get from the same tracking number; and
for fuck’s sake don’t make me login to obtain the fucking tracking).</p>
<h2 id="2025-07-08-1730--zed--claude-sonnet-4"><a class="header" href="#2025-07-08-1730--zed--claude-sonnet-4">2025-07-08 17:30 | Zed | Claude Sonnet 4</a></h2>
<p>I wanted to try agentic mode again on something less complicated, a fairly
mechanical conversion of a package from Javascript to Typescript. This is
something that we’re gradually doing a lot at work, as we have a large JS
codebase that we want to both break up into more-reusable components and also
move to Typescript, both for bug-catching and to align with our other
codebases. This is a multi-year endeavour at this point.</p>
<p>(As I write this content, hours after recording the timings and bones of the
interaction, I am struck by how hostile the agentic interface is to any kind of
recall or review of the history of the conversation. Home and Page Up don’t
work. Scrolling is strangely slow compared to the main editor window. There’s
no timestamps: I had to get into the habit early on of recording the times
manually as things happened because there’s simply no way to know when things
happened when reviewing a conversation or interaction with an agent. It’s both
really annoying and honestly kinda telling.)</p>
<p>Anyway, here’s the prompt:</p>
<blockquote>
<p>The api-client package is written in javascript, but now we need it in
typescript contexts. Without changing any functionality, switch it over.</p>
</blockquote>
<p>This was also given the “LLM rules” context from the work repo.</p>
<p>It immediately went along and started adding types and changing file extensions
and so on. At 17:37 it had done the conversion. This is not a large package, it
has five code files and something like thirty functions all up.</p>
<p>It then proceeded with the iterative process of running the build and fixing
errors. At 17:43 it was fully done, and stopped working. It provided this
summary of its work:</p>
<blockquote>
<p>The package now provides excellent TypeScript developer experience while
maintaining full compatibility with existing JavaScript consumers.</p>
</blockquote>
<p>Just to complete the experience, I asked it to commit the work, and also move
its branch so it could be merged more easily:</p>
<blockquote>
<p>commit this to a new branch, and then rebase it on top of feat/sync/streaming instead</p>
</blockquote>
<p>It took four minutes to achieve this, making numerous mistakes in the process
and painstakingly fixing them. This is, of course, three git commands, which
should take a competent human approximately fifteen seconds to remember and run.</p>
<p>This was the end of my day so I only did the analysis and review later:</p>
<ul>
<li>despite passing some of its local build tests, this conversion broke the
build</li>
<li>reviewing the conversation, it had failed to keep the code building in one of
the three forms that TS needs to transpile to (the JS ecosystem is a fucking
nightmare). It called this out while doing it, but forgot this entirely by
the time it got to its final summary, claiming both ESM and CJS builds
worked, while it had broken the ESM build</li>
<li>despite clear instruction, it changed the behaviour of the code in subtle
ways in several instances. These were probably cases where the TypeScript
compiler called out a typing error, and instead of calling this out or doing
more complex fixes such that behaviour wouldn’t change, it went the easy way.</li>
<li>it introduced code and build conventions that are inconsistent with the way
existing code and build processes looked.</li>
</ul>
<p>That last point is one that was revelatory to me, not in a direct way, but
because I’d already seen the different patterns it introduced: in another
package refactor a colleague had submitted some months back. This shows to me
that there’s a high likelihood that refactor was in fact done via an agentic
workflow, which isn’t that surprising, but more importantly that it wasn’t
reviewed and modified for consistency with the existing codebase before
submission. This is really something that sticks in my craw: not just that
coding AI agents by nature deliver the universal average with new code, but
also that gradually they will deliver the universal average to existing code
via under-reviewed agentic refactors. A codebase or workplace that has worked
hard for many years to cultivate excellence can, in a few short months of
uncritically adopting AI workflows everywhere, accidentally delete its own
culture in favour of the machine mediocre. Effects will be felt, but not
immediately enough to course-correct.</p>
<h2 id="2025-07-08-1030--zed--claude-sonnet-4"><a class="header" href="#2025-07-08-1030--zed--claude-sonnet-4">2025-07-08 10:30 | Zed | Claude Sonnet 4</a></h2>
<p>This was a hybrid, guided workflow. I started by manually making changes to the
LLM rules, then asked the agent to commit and push the rules, and then asked
the agent to make further changes to the rules and commits:</p>
<blockquote>
<p>@rules create a new branch, commit, push, and create a PR</p>
</blockquote>
<p>As per our current rules, it asked for a “ticket number”:</p>
<blockquote>
<p>I can see there are updates to several LLM rule files and a new rebase-branch
rule. However, I need the ticket code to create an appropriate branch name.
What’s the ticket code for this work?</p>
</blockquote>
<p>I noticed that the terminology was wrong, we use “card” instead of ticket. So:</p>
<blockquote>
<p>no ticket code, omit that. but before you push, modify the rules and commit
to clarify that we use “card” instead of “ticket”</p>
</blockquote>
<p>At this point, I made a mistake that would have been understood and corrected
by a human but wasn’t by this machine: I should have said to commit <em>my</em> work
and then do its own in a separate commit. As it was, it modified files and lost
the distinction.</p>
<p>When it committed, it therefore almagamated all the changes in one commit. I
asked it to split things up:</p>
<blockquote>
<p>undo the most recent commit, keeping its changes in the worktree, then split
it into a series of smaller meaningful commits, then force-push (with lease)
the branch</p>
</blockquote>
<p>It was a bit overzealous with that, creating three changes that should have
been one. Thus:</p>
<blockquote>
<p>squash the last three commits together and reword the commit message</p>
</blockquote>
<p>It then committed and pushed. At this point I noticed that it kept saying it
would create a PR, but actually all it was doing was creating a PR
<em>description</em> and then presenting it to the user. I quickly reviewed the
relevant rule manually and determined that was in fact its instructions. I
asked it to change that:</p>
<blockquote>
<p>modify the rule to create a PR, which detects if the <code>gh</code> or <code>hub</code> tools are
installed and uses those (in this order of preference) to create the PR from
the command line</p>
</blockquote>
<p>It did so appropriately, and then immediately created the PR using the new process.</p>
<p>Finally, I asked to include a mention in the PR body that it was created using
an agentic process:</p>
<blockquote>
<p>change the create-pr rule to add a “{agentic: Model Name}” label in the PR
description when creating a PR as an agent</p>
</blockquote>
<p>Analysis: this went a lot smoother. There were still minor mistakes but
arguably some of those are on me. This reinforces my impression that guided
workflows, like autocomplete and edit prediction, are a lot more effective than
autonomous agentic work.</p>
<hr />
<p>We then had an internal debate on terminology and I attempted to get the AI to
split out the ticket-&gt;card change into its own PR stacked on top:</p>
<blockquote>
<p>split out the ticket-&gt;card change into its own stacked branch and PR. go
through all commits in this branch to figure out if any need modification,
and keep all other commit messages as-is even if they get modified. then
force-push the current branch. reference the current PR in the new PR’s
description.</p>
</blockquote>
<p>This took it three tries as it changed tack after repeatedly failing. However,
at the last attempt, it was very pleased about itself:</p>
<blockquote>
<p>Perfect! Now the terminology branch contains only the changes that are
actually part of the terminology change</p>
</blockquote>
<p>In reality, the second branch contained half the commits, and it had stacked it
<em>under</em> the first branch, instead of on top (granted, I hadn’t specified, but
what a weird choice!). That is, not only the commit that had the rewording
change, but also other unrelated commits, which it had “helpfully” moved from
the first branch. Further, the commits weren’t pure due to its earlier fuck up
at the start of this interaction, and it had completely failed to follow
instructions and rewrite all the commits to split out the word change
thoroughly.</p>
<p>The result was so bad I manually backed out and closed the second PR it had
created. By then, so much time had passed that the debate going on in the
background had already reached a conclusion, removing the need for the split PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../technical/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../technical/g7-7700-nouveau.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../technical/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../technical/g7-7700-nouveau.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
